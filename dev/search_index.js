var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"W. R. Gilks and P. Wild. Adaptive rejection sampling for Gibbs Sampling. Applied Statistics 41, 337–348 (1992).\n\n\n\n","category":"page"},{"location":"api/#Public-API","page":"Public API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public API","title":"Public API","text":"Pages=[\"api.md\"]","category":"page"},{"location":"api/#ARS.ARSampler-Union{Tuple{G}, Tuple{F}, Tuple{T}, Tuple{ARS.Objective{F, G}, Vector{T}, Tuple{T, T}}} where {T<:AbstractFloat, F<:Function, G<:Function}","page":"Public API","title":"ARS.ARSampler","text":"ARSampler(\n    obj::ARS.Objective{F<:Function, G<:Function},\n    initial_points::Array{T<:AbstractFloat, 1},\n    domain::Tuple{T<:AbstractFloat, T<:AbstractFloat}\n) -> ARS.ARSampler{T, F, G} where {T<:AbstractFloat, F<:Function, G<:Function}\n\n\nInitialize an adaptive rejection sampler over a (log) objective function from obj. initial_points should be a vector of abscissae defining the initial segments of the sampler. At least 2 of the points should be on opposite sides of the objective function's maximum.\n\nARSampler(obj, initial_points, domain)\n\ndefined at /home/runner/work/ARS.jl/ARS.jl/src/ARS.jl:320.\n\n\n\n\n\n","category":"method"},{"location":"api/#ARS.Objective","page":"Public API","title":"ARS.Objective","text":"Objective(f)\nObjective(f, adbackend)\nObjective(f, adbackend, init)\n\n\nCreate an Objective for a function automatically generating its gradient. Gradients are calculated using DifferentiationInterface.jl using the backend of choice with Mooncake.jl being the default. In order to prepare the gradient an initial value is required. By default this is one(Float64). If a gradient for a different type is desired, it should be specified. \n\nwarning: Warning\nObserve that f should be in its log-concave form and that no checks are performed in order to verify this.\n\nExample\n\n# Create a sampler using `Mooncake.jl` autodiff and Float32 as its eltype\nARS.Objective(somefun, AutoMooncake(; config=nothing), one(Float32))\n# Create a sampler using `AutoDiff.jl` autodiff and the default Float64 as its eltype\nARS.Objective(somefun, AutoForwardDiff())\n\n\n\n\n\n","category":"type"},{"location":"api/#ARS.Objective-Tuple{Function, Function}","page":"Public API","title":"ARS.Objective","text":"Objective(f::Function, grad::Function) -> ARS.Objective\n\n\nCreate an Objective directly defined by its function f and custom gradient grad.\n\nwarning: Warning\nObserve that f should be in its log-concave form and that no checks are performed in order to verify this.\n\n\n\n\n\n","category":"method"},{"location":"api/#ARS.sample!","page":"Public API","title":"ARS.sample!","text":"sample!([rng=default_rng()], s::ARSampler, n::Integer, add_segments::Bool=true)\nsample!([rng=default_rng()], v::AbstractVector, s::ARSampler, add_segments::Bool=true)\n\nDraw samples from s. If supplied, a vector v will be filled with samples. Otherwise the number of samples is specified with n.\n\n\n\n\n\n","category":"function"},{"location":"#ARS","page":"Home","title":"ARS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ARS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements univariate adaptive rejection sampling as specified by Gilks & Wild [1].","category":"page"},{"location":"#Showcase","page":"Home","title":"Showcase","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ARS allows you to sample from unnormalized logarithmically concave distributions. In the following example we will sample from an unnormalized normal distribution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using ARS, CairoMakie, Distributions, Random\nset_theme!(theme_minimal())\nupdate_theme!(linewidth = 6)\nupdate_theme!(fonts = (; regular = \"DejaVu Sans\"))\nRandom.seed!(1)\nCairoMakie.activate!(; type=\"svg\") # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets use a normal distribution centered on pi with standard deviation 2.","category":"page"},{"location":"","page":"Home","title":"Home","text":"const mu::Float64 = π\nconst sigma::Float64 = 2.0\n\n# Define a normal distribution without the normalizing terms.\nf(x) = exp(-((x - mu)^2) / (2 * sigma^2))\n\n# Use the normal distribution from Distributions.jl for verification.\nnormal(x) = pdf(Normal(mu, sigma), x)\n\nl, u = mu - sigma * 4, mu + sigma * 4\nfig, ax, p = lines(l..u, f, label = \"Unnormalized density\")\nlines!(ax, l..u, normal, label = \"Actual normal distribution\")\naxislegend(ax)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's imagine we did not know the actual normalizing constant for the normal distribution above. In order to sample from it using ARS, we first define an objective function using ARS.Objective. By default, automatic differentiation through Mooncake.jl is used to calculate the derivative of the function to be sampled from.","category":"page"},{"location":"","page":"Home","title":"Home","text":"First, we need to supply the function in its log form. For illustration purposes, we simply do log(f(x)).","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_log(x) = log(f(x))\nobj = ARS.Objective(f_log)","category":"page"},{"location":"","page":"Home","title":"Home","text":"We then define the sampler itself providing the initial points for the hull as well as the desired domain. Initial points needs to be at opposing sides of the function maximum.","category":"page"},{"location":"","page":"Home","title":"Home","text":"sam = ARS.ARSampler(obj, [-2., 4.], (-Inf, Inf))","category":"page"},{"location":"","page":"Home","title":"Home","text":"In order to retrieve samples, we use the ARS.sample! function. As is indicated by the !, this function modifies the sampler itself in order to improve future sampling whenever a sample is rejected.","category":"page"},{"location":"","page":"Home","title":"Home","text":"samples = ARS.sample!(sam, 1000);","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets compare the samples drawn from the sampler to the actual target distribution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fig, ax, p = hist(samples, bins=100, normalization = :pdf, label = \"Samples\", axis = (; title=\"1000 samples\"))\nlines!(l..u, normal, label = \"Target distribution\", color = :orange, linewidth = 3, alpha = 0.8)\naxislegend(ax)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets do one with more samples in order to verify that it actually approaches the target.","category":"page"},{"location":"","page":"Home","title":"Home","text":"fig, ax, p = hist(ARS.sample!(sam, 100000), bins=100, normalization = :pdf, label = \"Samples\", axis=(; title=\"100 000 samples\")) # hide\nlines!(l..u, normal, label = \"Target distribution\", color = :orange, alpha = 0.8) # hide\naxislegend(ax) # hide\nfig # hide","category":"page"},{"location":"#Truncated-density","page":"Home","title":"Truncated density","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Lets try a truncated density such as the beta distribution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As before, we define the distribution without its normalizing terms as well as a function from Distributions.jl to compare with.","category":"page"},{"location":"","page":"Home","title":"Home","text":"const alpha::Float64 = 2.5\nconst beta::Float64 = 5.0\n\nf(x) = x^(alpha - 1) * (1 - x)^(beta - 1)\n\nbeta_proper(x) = pdf(Beta(alpha, beta), x)\n\nl, u = 0, 1\nfig, ax, p = lines(l..u, f, label=\"Unnormalized density\")\nlines!(ax, l..u, beta_proper, label = \"Actual beta distribution\")\naxislegend(ax)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets define the objective and sampler. As the beta distribution is bounded on x in 0 1 we specify this in the domain argument when creating the sampler.","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_log(x) = log(f(x))\nobj = ARS.Objective(f_log)\n\nsam = ARS.ARSampler(obj, [0.2, 0.8], (0.0, 1.0))\nnothing # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Lets visualize the samples as before.","category":"page"},{"location":"","page":"Home","title":"Home","text":"samples = ARS.sample!(sam, 100000)\n\nfig, ax, p = hist(samples, bins=100, label = \"Samples\", normalization = :pdf)\nlines!(ax, 0..1, beta_proper, label = \"Target\", color = Cycled(2))\naxislegend(ax)\nfig # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Of course, we can specify arbitrary bounds. Let's define the same beta distribution as above but truncated at 05 10 and compare them with sampling from a truncated Distributions.jl distribution. (with plotting code hidden for brevity).","category":"page"},{"location":"","page":"Home","title":"Home","text":"sam_bounded = ARS.ARSampler(obj, [0.8], (0.5, 1.0))\n\nsamples_bounded = ARS.sample!(sam_bounded, 100000)\n\ndist_bounded = truncated(Beta(alpha, beta), lower=0.5)\n\nsamples_true = rand(dist_bounded, 100000)\n\nfig, ax, p = density( # hide\n    samples_bounded,  # hide\n    label = \"ARS samples\",  # hide\n    color = :transparent,  # hide\n    strokewidth = 6, # hide\n    boundary = (0.0, 1.0) # hide\n) # hide\ndensity!( # hide\n    ax, # hide\n    samples_true,  # hide\n    label = \"Distributions.jl\", # hide\n    color = :transparent,  # hide\n    strokewidth = 6, # hide\n    linestyle = :dot, # hide\n    boundary = (0.0, 1.0) # hide\n) # hide\nLegend( # hide\n    fig[1,1], # hide\n    [elem_ars, elem_dist], # hide\n    [\"ARS.jl\", \"Distributions.jl\"], # hide\n    tellheight = false, # hide\n    tellwidth = false, # hide\n    margin = (10, 10, 10, 10), # hide\n    halign = :right, # hide\n    valign = :top, # hide\n) # hide\nfig # hide","category":"page"},{"location":"devdocs/#Developer-docs","page":"Internals","title":"Developer docs","text":"","category":"section"},{"location":"devdocs/","page":"Internals","title":"Internals","text":"Pages=[\"devdocs.md\"]","category":"page"},{"location":"devdocs/#ARS.AllocFreeWeights","page":"Internals","title":"ARS.AllocFreeWeights","text":"struct AllocFreeWeights{S<:Real, T<:Number, V<:AbstractArray{T<:Number, 1}} <: StatsBase.AbstractWeights{S<:Real, T<:Number, V<:AbstractArray{T<:Number, 1}}\n\nNon-mutable weights used in the sample function in this package in order to avoid allocations.\n\nvalues::AbstractVector{T} where T<:Number\nsum::Real\n\n\n\n\n\n","category":"type"},{"location":"devdocs/#ARS.__sample!-Union{Tuple{T}, Tuple{Random.AbstractRNG, AbstractVector{T}, ARS.ARSampler{T}, Bool}} where T<:AbstractFloat","page":"Internals","title":"ARS.__sample!","text":"__sample!(rng::AbstractRNG, out::Vector{T}, s::ARSampler{T}, add_segments::Bool) where {T<:AbstractFloat}\n\nAll other __sample! methods call this one.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.add_segment!-Union{Tuple{T}, Tuple{ARS.ARSampler{T}, T}} where T<:AbstractFloat","page":"Internals","title":"ARS.add_segment!","text":"add_segment!(\n    s::ARS.ARSampler{T<:AbstractFloat},\n    x::AbstractFloat\n)\n\n\nModifies the hulls of s, adding a segment with at x.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.calc_domain_integral_exp-Tuple{ARS.UpperHull}","page":"Internals","title":"ARS.calc_domain_integral_exp","text":"calc_domain_integral_exp(hull::UpperHull)\n\nCalculate the domain integral of hull.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.eval_hull-Tuple{ARS.UpperHull, Any}","page":"Internals","title":"ARS.eval_hull","text":"Eval hull h at x.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.exp_integral_line-NTuple{4, Any}","page":"Internals","title":"ARS.exp_integral_line","text":"exp_integral_line(slope, intercept, x1, x2)\n\nCalculate the integral of exp(slope * x + intercept) between x1 and x2. Handles a slope of 0.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.intersection-Union{Tuple{T}, NTuple{4, T}} where T","page":"Internals","title":"ARS.intersection","text":"Returns the intersection abscissa between 2 lines as defined by their slopes and intercepts. Returns NaN if the lines are paralell.\n\n\n\n\n\n","category":"method"},{"location":"devdocs/#ARS.line-Tuple{ARS.UpperHull, Integer}","page":"Internals","title":"ARS.line","text":"Get line i from the hull. Returns a tuple consisting of (slope, intercept).\n\n\n\n\n\n","category":"method"}]
}
